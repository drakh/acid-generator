{"version":3,"sources":["../index.ts"],"sourcesContent":["import { detect } from \"@tonaljs/chord-detect\";\nimport {\n  ChordType,\n  all as chordTypes,\n  get as getChordType,\n} from \"@tonaljs/chord-type\";\nimport { tonicIntervalsTransposer } from \"@tonaljs/core\";\n\nimport {\n  deprecate,\n  distance,\n  note,\n  NoteName,\n  tokenizeNote,\n  transpose as transposeNote,\n} from \"@tonaljs/core\";\n\nimport { isSubsetOf, isSupersetOf } from \"@tonaljs/pcset\";\n\nimport { all as scaleTypes } from \"@tonaljs/scale-type\";\nexport { detect } from \"@tonaljs/chord-detect\";\n\ntype ChordName = string;\ntype ChordNameTokens = [string, string]; // [TONIC, SCALE TYPE]\n\nexport interface Chord extends ChordType {\n  tonic: string | null;\n  type: string;\n  root: string;\n  rootDegree: number;\n  symbol: string;\n  notes: NoteName[];\n}\n\nconst NoChord: Chord = {\n  empty: true,\n  name: \"\",\n  symbol: \"\",\n  root: \"\",\n  rootDegree: 0,\n  type: \"\",\n  tonic: null,\n  setNum: NaN,\n  quality: \"Unknown\",\n  chroma: \"\",\n  normalized: \"\",\n  aliases: [],\n  notes: [],\n  intervals: [],\n};\n\n// 6, 64, 7, 9, 11 and 13 are consider part of the chord\n// (see https://github.com/danigb/tonal/issues/55)\nconst NUM_TYPES = /^(6|64|7|9|11|13)$/;\n/**\n * Tokenize a chord name. It returns an array with the tonic and chord type\n * If not tonic is found, all the name is considered the chord name.\n *\n * This function does NOT check if the chord type exists or not. It only tries\n * to split the tonic and chord type.\n *\n * @function\n * @param {string} name - the chord name\n * @return {Array} an array with [tonic, type]\n * @example\n * tokenize(\"Cmaj7\") // => [ \"C\", \"maj7\" ]\n * tokenize(\"C7\") // => [ \"C\", \"7\" ]\n * tokenize(\"mMaj7\") // => [ null, \"mMaj7\" ]\n * tokenize(\"Cnonsense\") // => [ null, \"nonsense\" ]\n */\nexport function tokenize(name: string): ChordNameTokens {\n  const [letter, acc, oct, type] = tokenizeNote(name);\n  if (letter === \"\") {\n    return [\"\", name];\n  }\n  // aug is augmented (see https://github.com/danigb/tonal/issues/55)\n  if (letter === \"A\" && type === \"ug\") {\n    return [\"\", \"aug\"];\n  }\n  return [letter + acc, oct + type];\n}\n\n/**\n * Get a Chord from a chord name.\n */\nexport function get(src: ChordName | ChordNameTokens): Chord {\n  if (src === \"\") {\n    return NoChord;\n  }\n  if (Array.isArray(src) && src.length === 2) {\n    return getChord(src[1], src[0]);\n  } else {\n    const [tonic, type] = tokenize(src);\n    const chord = getChord(type, tonic);\n    return chord.empty ? getChord(src) : chord;\n  }\n}\n\n/**\n * Get chord properties\n *\n * @param typeName - the chord type name\n * @param [tonic] - Optional tonic\n * @param [root]  - Optional root (requires a tonic)\n */\nexport function getChord(\n  typeName: string,\n  optionalTonic?: string,\n  optionalRoot?: string\n): Chord {\n  const type = getChordType(typeName);\n  const tonic = note(optionalTonic || \"\");\n  const root = note(optionalRoot || \"\");\n\n  if (\n    type.empty ||\n    (optionalTonic && tonic.empty) ||\n    (optionalRoot && root.empty)\n  ) {\n    return NoChord;\n  }\n\n  const rootInterval = distance(tonic.pc, root.pc);\n  const rootDegree = type.intervals.indexOf(rootInterval) + 1;\n  if (!root.empty && !rootDegree) {\n    return NoChord;\n  }\n\n  const intervals = Array.from(type.intervals);\n\n  for (let i = 1; i < rootDegree; i++) {\n    const num = intervals[0][0];\n    const quality = intervals[0][1];\n    const newNum = parseInt(num, 10) + 7;\n    intervals.push(`${newNum}${quality}`);\n    intervals.shift();\n  }\n\n  const notes = tonic.empty\n    ? []\n    : intervals.map((i) => transposeNote(tonic, i));\n\n  typeName = type.aliases.indexOf(typeName) !== -1 ? typeName : type.aliases[0];\n  const symbol = `${tonic.empty ? \"\" : tonic.pc}${typeName}${\n    root.empty || rootDegree <= 1 ? \"\" : \"/\" + root.pc\n  }`;\n  const name = `${optionalTonic ? tonic.pc + \" \" : \"\"}${type.name}${\n    rootDegree > 1 && optionalRoot ? \" over \" + root.pc : \"\"\n  }`;\n  return {\n    ...type,\n    name,\n    symbol,\n    type: type.name,\n    root: root.name,\n    intervals,\n    rootDegree,\n    tonic: tonic.name,\n    notes,\n  };\n}\n\nexport const chord = deprecate(\"Chord.chord\", \"Chord.get\", get);\n\n/**\n * Transpose a chord name\n *\n * @param {string} chordName - the chord name\n * @return {string} the transposed chord\n *\n * @example\n * transpose('Dm7', 'P4') // => 'Gm7\n */\nexport function transpose(chordName: string, interval: string): string {\n  const [tonic, type] = tokenize(chordName);\n  if (!tonic) {\n    return chordName;\n  }\n  return transposeNote(tonic, interval) + type;\n}\n\n/**\n * Get all scales where the given chord fits\n *\n * @example\n * chordScales('C7b9')\n * // => [\"phrygian dominant\", \"flamenco\", \"spanish heptatonic\", \"half-whole diminished\", \"chromatic\"]\n */\nexport function chordScales(name: string): string[] {\n  const s = get(name);\n  const isChordIncluded = isSupersetOf(s.chroma);\n  return scaleTypes()\n    .filter((scale) => isChordIncluded(scale.chroma))\n    .map((scale) => scale.name);\n}\n/**\n * Get all chords names that are a superset of the given one\n * (has the same notes and at least one more)\n *\n * @function\n * @example\n * extended(\"CMaj7\")\n * // => [ 'Cmaj#4', 'Cmaj7#9#11', 'Cmaj9', 'CM7add13', 'Cmaj13', 'Cmaj9#11', 'CM13#11', 'CM7b9' ]\n */\nexport function extended(chordName: string): string[] {\n  const s = get(chordName);\n  const isSuperset = isSupersetOf(s.chroma);\n  return chordTypes()\n    .filter((chord) => isSuperset(chord.chroma))\n    .map((chord) => s.tonic + chord.aliases[0]);\n}\n\n/**\n * Find all chords names that are a subset of the given one\n * (has less notes but all from the given chord)\n *\n * @example\n */\nexport function reduced(chordName: string): string[] {\n  const s = get(chordName);\n  const isSubset = isSubsetOf(s.chroma);\n  return chordTypes()\n    .filter((chord) => isSubset(chord.chroma))\n    .map((chord) => s.tonic + chord.aliases[0]);\n}\n\n/**\n * Returns a function to get a note name from the scale degree.\n *\n * @example\n * [1, 2, 3, 4].map(Chord.degrees(\"C\")) => [\"C\", \"E\", \"G\", \"C\"]\n * [1, 2, 3, 4].map(Chord.degrees(\"C4\")) => [\"C4\", \"E4\", \"G4\", \"C5\"]\n */\nexport function degrees(chordName: string | ChordNameTokens) {\n  const { intervals, tonic } = get(chordName);\n  const transpose = tonicIntervalsTransposer(intervals, tonic);\n  return (degree: number) =>\n    degree ? transpose(degree > 0 ? degree - 1 : degree) : \"\";\n}\n\n/**\n * Sames as `degree` but with 0-based index\n */\nexport function steps(chordName: string | ChordNameTokens) {\n  const { intervals, tonic } = get(chordName);\n  return tonicIntervalsTransposer(intervals, tonic);\n}\n\nexport default {\n  getChord,\n  get,\n  detect,\n  chordScales,\n  extended,\n  reduced,\n  tokenize,\n  transpose,\n  degrees,\n  steps,\n\n  // deprecate\n  chord,\n};\n"],"mappings":"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","names":["import_core","import_chord_detect","chord","getChordType","transposeNote","scaleTypes","chordTypes","transpose"]}