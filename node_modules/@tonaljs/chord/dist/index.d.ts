import { detect } from '@tonaljs/chord-detect';
export { detect } from '@tonaljs/chord-detect';
import { ChordType } from '@tonaljs/chord-type';
import { NoteName } from '@tonaljs/core';

type ChordName = string;
type ChordNameTokens = [string, string];
interface Chord extends ChordType {
    tonic: string | null;
    type: string;
    root: string;
    rootDegree: number;
    symbol: string;
    notes: NoteName[];
}
/**
 * Tokenize a chord name. It returns an array with the tonic and chord type
 * If not tonic is found, all the name is considered the chord name.
 *
 * This function does NOT check if the chord type exists or not. It only tries
 * to split the tonic and chord type.
 *
 * @function
 * @param {string} name - the chord name
 * @return {Array} an array with [tonic, type]
 * @example
 * tokenize("Cmaj7") // => [ "C", "maj7" ]
 * tokenize("C7") // => [ "C", "7" ]
 * tokenize("mMaj7") // => [ null, "mMaj7" ]
 * tokenize("Cnonsense") // => [ null, "nonsense" ]
 */
declare function tokenize(name: string): ChordNameTokens;
/**
 * Get a Chord from a chord name.
 */
declare function get(src: ChordName | ChordNameTokens): Chord;
/**
 * Get chord properties
 *
 * @param typeName - the chord type name
 * @param [tonic] - Optional tonic
 * @param [root]  - Optional root (requires a tonic)
 */
declare function getChord(typeName: string, optionalTonic?: string, optionalRoot?: string): Chord;
declare const chord: (this: unknown, ...args: unknown[]) => Chord;
/**
 * Transpose a chord name
 *
 * @param {string} chordName - the chord name
 * @return {string} the transposed chord
 *
 * @example
 * transpose('Dm7', 'P4') // => 'Gm7
 */
declare function transpose(chordName: string, interval: string): string;
/**
 * Get all scales where the given chord fits
 *
 * @example
 * chordScales('C7b9')
 * // => ["phrygian dominant", "flamenco", "spanish heptatonic", "half-whole diminished", "chromatic"]
 */
declare function chordScales(name: string): string[];
/**
 * Get all chords names that are a superset of the given one
 * (has the same notes and at least one more)
 *
 * @function
 * @example
 * extended("CMaj7")
 * // => [ 'Cmaj#4', 'Cmaj7#9#11', 'Cmaj9', 'CM7add13', 'Cmaj13', 'Cmaj9#11', 'CM13#11', 'CM7b9' ]
 */
declare function extended(chordName: string): string[];
/**
 * Find all chords names that are a subset of the given one
 * (has less notes but all from the given chord)
 *
 * @example
 */
declare function reduced(chordName: string): string[];
/**
 * Returns a function to get a note name from the scale degree.
 *
 * @example
 * [1, 2, 3, 4].map(Chord.degrees("C")) => ["C", "E", "G", "C"]
 * [1, 2, 3, 4].map(Chord.degrees("C4")) => ["C4", "E4", "G4", "C5"]
 */
declare function degrees(chordName: string | ChordNameTokens): (degree: number) => string;
/**
 * Sames as `degree` but with 0-based index
 */
declare function steps(chordName: string | ChordNameTokens): (normalized: number) => string;
declare const _default: {
    getChord: typeof getChord;
    get: typeof get;
    detect: typeof detect;
    chordScales: typeof chordScales;
    extended: typeof extended;
    reduced: typeof reduced;
    tokenize: typeof tokenize;
    transpose: typeof transpose;
    degrees: typeof degrees;
    steps: typeof steps;
    chord: (this: unknown, ...args: unknown[]) => Chord;
};

export { Chord, chord, chordScales, _default as default, degrees, extended, get, getChord, reduced, steps, tokenize, transpose };
