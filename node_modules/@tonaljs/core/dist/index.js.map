{"version":3,"sources":["../index.ts","../src/utils.ts","../src/named.ts","../src/pitch.ts","../src/note.ts","../src/interval.ts","../src/distance.ts"],"sourcesContent":["export * from \"./src/utils\";\nexport * from \"./src/named\";\nexport * from \"./src/pitch\";\nexport * from \"./src/note\";\nexport * from \"./src/interval\";\nexport * from \"./src/distance\";\n","/**\n * Fill a string with a repeated character\n *\n * @param character\n * @param repetition\n */\nexport const fillStr = (s: string, n: number) => Array(Math.abs(n) + 1).join(s);\n\nexport function deprecate<\n  ResultFn extends (this: any, ...newArgs: any[]) => ReturnType<ResultFn>\n>(original: string, alternative: string, fn: ResultFn) {\n  return function (this: unknown, ...args: unknown[]): ReturnType<ResultFn> {\n    // tslint:disable-next-line\n    console.warn(`${original} is deprecated. Use ${alternative}.`);\n    return fn.apply(this, args);\n  };\n}\n","export interface Named {\n  readonly name: string;\n}\n\nexport interface NamedFound {\n  readonly empty: false;\n}\n\nexport interface NotFound extends Named {\n  readonly empty: true;\n  readonly name: \"\";\n}\n\nexport function isNamed(src: any): src is Named {\n  return src !== null && typeof src === \"object\" && typeof src.name === \"string\"\n    ? true\n    : false;\n}\n","import { Named } from \"./named\";\n\ntype Fifths = number;\ntype Octaves = number;\nexport type Direction = 1 | -1;\n\nexport type PitchClassCoordinates = [Fifths];\nexport type NoteCoordinates = [Fifths, Octaves];\nexport type IntervalCoordinates = [Fifths, Octaves, Direction];\nexport type PitchCoordinates =\n  | PitchClassCoordinates\n  | NoteCoordinates\n  | IntervalCoordinates;\n\n/**\n * Pitch properties\n *\n * - {number} step - The step number: 0 = C, 1 = D, ... 6 = B\n * - {number} alt - Number of alterations: -2 = 'bb', -1 = 'b', 0 = '', 1 = '#', ...\n * - {number} [oct] = The octave (undefined when is a coord class)\n * - {number} [dir] = Interval direction (undefined when is not an interval)\n */\nexport interface Pitch {\n  readonly step: number;\n  readonly alt: number;\n  readonly oct?: number; // undefined for pitch classes\n  readonly dir?: Direction; // undefined for notes\n}\n\nexport function isPitch(pitch: any): pitch is Pitch {\n  return pitch !== null &&\n    typeof pitch === \"object\" &&\n    typeof pitch.step === \"number\" &&\n    typeof pitch.alt === \"number\"\n    ? true\n    : false;\n}\n\n// The number of fifths of [C, D, E, F, G, A, B]\nconst FIFTHS = [0, 2, 4, -1, 1, 3, 5];\n// The number of octaves it span each step\nconst STEPS_TO_OCTS = FIFTHS.map((fifths: number) =>\n  Math.floor((fifths * 7) / 12)\n);\n\nexport function encode(pitch: Pitch): PitchCoordinates {\n  const { step, alt, oct, dir = 1 } = pitch;\n  const f = FIFTHS[step] + 7 * alt;\n  if (oct === undefined) {\n    return [dir * f];\n  }\n  const o = oct - STEPS_TO_OCTS[step] - 4 * alt;\n  return [dir * f, dir * o];\n}\n\n// We need to get the steps from fifths\n// Fifths for CDEFGAB are [ 0, 2, 4, -1, 1, 3, 5 ]\n// We add 1 to fifths to avoid negative numbers, so:\n// for [\"F\", \"C\", \"G\", \"D\", \"A\", \"E\", \"B\"] we have:\nconst FIFTHS_TO_STEPS = [3, 0, 4, 1, 5, 2, 6];\n\nexport function decode(coord: PitchCoordinates): Pitch {\n  const [f, o, dir] = coord;\n  const step = FIFTHS_TO_STEPS[unaltered(f)];\n  const alt = Math.floor((f + 1) / 7);\n  if (o === undefined) {\n    return { step, alt, dir };\n  }\n  const oct = o + 4 * alt + STEPS_TO_OCTS[step];\n  return { step, alt, oct, dir };\n}\n\n// Return the number of fifths as if it were unaltered\nfunction unaltered(f: number): number {\n  const i = (f + 1) % 7;\n  return i < 0 ? 7 + i : i;\n}\n","import { isNamed, Named } from \"./named\";\nimport { decode, encode, isPitch, Pitch, PitchCoordinates } from \"./pitch\";\nimport { fillStr } from \"./utils\";\n\nexport type NoteWithOctave = string;\nexport type PcName = string;\nexport type NoteName = NoteWithOctave | PcName;\nexport type NoteLiteral = NoteName | Pitch | Named;\n\nexport interface Note extends Pitch, Named {\n  readonly empty: boolean;\n  readonly name: NoteName;\n  readonly letter: string;\n  readonly acc: string;\n  readonly pc: PcName;\n  readonly chroma: number;\n  readonly height: number;\n  readonly coord: PitchCoordinates;\n  readonly midi: number | null;\n  readonly freq: number | null;\n}\n\nexport interface NoNote extends Partial<Note> {\n  empty: true;\n  name: \"\";\n  pc: \"\";\n  acc: \"\";\n}\nconst NoNote: NoNote = { empty: true, name: \"\", pc: \"\", acc: \"\" };\n\nconst cache: Map<NoteLiteral | undefined, Note | NoNote> = new Map();\n\nexport const stepToLetter = (step: number) => \"CDEFGAB\".charAt(step);\nexport const altToAcc = (alt: number): string =>\n  alt < 0 ? fillStr(\"b\", -alt) : fillStr(\"#\", alt);\nexport const accToAlt = (acc: string): number =>\n  acc[0] === \"b\" ? -acc.length : acc.length;\n\n/**\n * Given a note literal (a note name or a note object), returns the Note object\n * @example\n * note('Bb4') // => { name: \"Bb4\", midi: 70, chroma: 10, ... }\n */\nexport function note(src: NoteLiteral): Note | NoNote {\n  const stringSrc = JSON.stringify(src);\n\n  const cached = cache.get(stringSrc);\n  if (cached) {\n    return cached;\n  }\n\n  const value =\n    typeof src === \"string\"\n      ? parse(src)\n      : isPitch(src)\n      ? note(pitchName(src))\n      : isNamed(src)\n      ? note(src.name)\n      : NoNote;\n  cache.set(stringSrc, value);\n  return value;\n}\n\ntype NoteTokens = [string, string, string, string];\n\nconst REGEX = /^([a-gA-G]?)(#{1,}|b{1,}|x{1,}|)(-?\\d*)\\s*(.*)$/;\n\n/**\n * @private\n */\nexport function tokenizeNote(str: string): NoteTokens {\n  const m = REGEX.exec(str) as string[];\n  return [m[1].toUpperCase(), m[2].replace(/x/g, \"##\"), m[3], m[4]];\n}\n\n/**\n * @private\n */\nexport function coordToNote(noteCoord: PitchCoordinates): Note {\n  return note(decode(noteCoord)) as Note;\n}\n\nconst mod = (n: number, m: number) => ((n % m) + m) % m;\n\nconst SEMI = [0, 2, 4, 5, 7, 9, 11];\nfunction parse(noteName: NoteName): Note | NoNote {\n  const tokens = tokenizeNote(noteName);\n  if (tokens[0] === \"\" || tokens[3] !== \"\") {\n    return NoNote;\n  }\n\n  const letter = tokens[0];\n  const acc = tokens[1];\n  const octStr = tokens[2];\n\n  const step = (letter.charCodeAt(0) + 3) % 7;\n  const alt = accToAlt(acc);\n  const oct = octStr.length ? +octStr : undefined;\n  const coord = encode({ step, alt, oct });\n\n  const name = letter + acc + octStr;\n  const pc = letter + acc;\n  const chroma = (SEMI[step] + alt + 120) % 12;\n  const height =\n    oct === undefined\n      ? mod(SEMI[step] + alt, 12) - 12 * 99\n      : SEMI[step] + alt + 12 * (oct + 1);\n  const midi = height >= 0 && height <= 127 ? height : null;\n  const freq = oct === undefined ? null : Math.pow(2, (height - 69) / 12) * 440;\n\n  return {\n    empty: false,\n    acc,\n    alt,\n    chroma,\n    coord,\n    freq,\n    height,\n    letter,\n    midi,\n    name,\n    oct,\n    pc,\n    step,\n  };\n}\n\nfunction pitchName(props: Pitch): NoteName {\n  const { step, alt, oct } = props;\n  const letter = stepToLetter(step);\n  if (!letter) {\n    return \"\";\n  }\n\n  const pc = letter + altToAcc(alt);\n  return oct || oct === 0 ? pc + oct : pc;\n}\n","import { isNamed, Named } from \"./named\";\nimport {\n  decode,\n  Direction,\n  encode,\n  IntervalCoordinates,\n  isPitch,\n  Pitch,\n  PitchCoordinates,\n} from \"./pitch\";\nimport { fillStr } from \"./utils\";\n\nexport type IntervalName = string;\nexport type IntervalLiteral = IntervalName | Pitch | Named;\n\ntype Quality =\n  | \"dddd\"\n  | \"ddd\"\n  | \"dd\"\n  | \"d\"\n  | \"m\"\n  | \"M\"\n  | \"P\"\n  | \"A\"\n  | \"AA\"\n  | \"AAA\"\n  | \"AAAA\";\ntype Type = \"perfectable\" | \"majorable\";\n\nexport interface Interval extends Pitch, Named {\n  readonly empty: boolean;\n  readonly name: IntervalName;\n  readonly num: number;\n  readonly q: Quality;\n  readonly type: Type;\n  readonly step: number;\n  readonly alt: number;\n  readonly dir: Direction;\n  readonly simple: number;\n  readonly semitones: number;\n  readonly chroma: number;\n  readonly coord: IntervalCoordinates;\n  readonly oct: number;\n}\n\nexport interface NoInterval extends Partial<Interval> {\n  readonly empty: true;\n  readonly name: \"\";\n  readonly acc: \"\";\n}\n\nconst NoInterval: NoInterval = { empty: true, name: \"\", acc: \"\" };\n\n// shorthand tonal notation (with quality after number)\nconst INTERVAL_TONAL_REGEX = \"([-+]?\\\\d+)(d{1,4}|m|M|P|A{1,4})\";\n// standard shorthand notation (with quality before number)\nconst INTERVAL_SHORTHAND_REGEX = \"(AA|A|P|M|m|d|dd)([-+]?\\\\d+)\";\nconst REGEX = new RegExp(\n  \"^\" + INTERVAL_TONAL_REGEX + \"|\" + INTERVAL_SHORTHAND_REGEX + \"$\"\n);\n\ntype IntervalTokens = [string, string];\n\n/**\n * @private\n */\nexport function tokenizeInterval(str?: IntervalName): IntervalTokens {\n  const m = REGEX.exec(`${str}`);\n  if (m === null) {\n    return [\"\", \"\"];\n  }\n  return m[1] ? [m[1], m[2]] : [m[4], m[3]];\n}\n\nconst cache: { [key in string]: Interval | NoInterval } = {};\n\n/**\n * Get interval properties. It returns an object with:\n *\n * - name: the interval name\n * - num: the interval number\n * - type: 'perfectable' or 'majorable'\n * - q: the interval quality (d, m, M, A)\n * - dir: interval direction (1 ascending, -1 descending)\n * - simple: the simplified number\n * - semitones: the size in semitones\n * - chroma: the interval chroma\n *\n * @param {string} interval - the interval name\n * @return {Object} the interval properties\n *\n * @example\n * import { interval } from '@tonaljs/core'\n * interval('P5').semitones // => 7\n * interval('m3').type // => 'majorable'\n */\nexport function interval(src: IntervalLiteral): Interval | NoInterval {\n  return typeof src === \"string\"\n    ? cache[src] || (cache[src] = parse(src))\n    : isPitch(src)\n    ? interval(pitchName(src))\n    : isNamed(src)\n    ? interval(src.name)\n    : NoInterval;\n}\n\nconst SIZES = [0, 2, 4, 5, 7, 9, 11];\nconst TYPES = \"PMMPPMM\";\nfunction parse(str?: string): Interval | NoInterval {\n  const tokens = tokenizeInterval(str);\n  if (tokens[0] === \"\") {\n    return NoInterval;\n  }\n  const num = +tokens[0];\n  const q = tokens[1] as Quality;\n  const step = (Math.abs(num) - 1) % 7;\n  const t = TYPES[step];\n  if (t === \"M\" && q === \"P\") {\n    return NoInterval;\n  }\n  const type = t === \"M\" ? \"majorable\" : \"perfectable\";\n\n  const name = \"\" + num + q;\n  const dir = num < 0 ? -1 : 1;\n  const simple = num === 8 || num === -8 ? num : dir * (step + 1);\n  const alt = qToAlt(type, q);\n  const oct = Math.floor((Math.abs(num) - 1) / 7);\n  const semitones = dir * (SIZES[step] + alt + 12 * oct);\n  const chroma = (((dir * (SIZES[step] + alt)) % 12) + 12) % 12;\n  const coord = encode({ step, alt, oct, dir }) as IntervalCoordinates;\n  return {\n    empty: false,\n    name,\n    num,\n    q,\n    step,\n    alt,\n    dir,\n    type,\n    simple,\n    semitones,\n    chroma,\n    coord,\n    oct,\n  };\n}\n\n/**\n * @private\n *\n * forceDescending is used in the case of unison (#243)\n */\nexport function coordToInterval(\n  coord: PitchCoordinates,\n  forceDescending?: boolean\n): Interval {\n  const [f, o = 0] = coord;\n  const isDescending = f * 7 + o * 12 < 0;\n  const ivl: IntervalCoordinates =\n    forceDescending || isDescending ? [-f, -o, -1] : [f, o, 1];\n  return interval(decode(ivl)) as Interval;\n}\n\nfunction qToAlt(type: Type, q: string): number {\n  return (q === \"M\" && type === \"majorable\") ||\n    (q === \"P\" && type === \"perfectable\")\n    ? 0\n    : q === \"m\" && type === \"majorable\"\n    ? -1\n    : /^A+$/.test(q)\n    ? q.length\n    : /^d+$/.test(q)\n    ? -1 * (type === \"perfectable\" ? q.length : q.length + 1)\n    : 0;\n}\n\n// return the interval name of a pitch\nfunction pitchName(props: Pitch): string {\n  const { step, alt, oct = 0, dir } = props;\n  if (!dir) {\n    return \"\";\n  }\n  const calcNum = step + 1 + 7 * oct;\n  // this is an edge case: descending pitch class unison (see #243)\n  const num = calcNum === 0 ? step + 1 : calcNum;\n  const d = dir < 0 ? \"-\" : \"\";\n  const type = TYPES[step] === \"M\" ? \"majorable\" : \"perfectable\";\n  const name = d + num + altToQ(type, alt);\n  return name;\n}\n\nfunction altToQ(type: Type, alt: number): Quality {\n  if (alt === 0) {\n    return type === \"majorable\" ? \"M\" : \"P\";\n  } else if (alt === -1 && type === \"majorable\") {\n    return \"m\";\n  } else if (alt > 0) {\n    return fillStr(\"A\", alt) as Quality;\n  } else {\n    return fillStr(\"d\", type === \"perfectable\" ? alt : alt + 1) as Quality;\n  }\n}\n","import {\n  coordToInterval,\n  interval as asInterval,\n  IntervalLiteral,\n  IntervalName,\n} from \"./interval\";\nimport { coordToNote, note as asNote, NoteLiteral, NoteName } from \"./note\";\nimport { PitchCoordinates } from \"./pitch\";\n\n/**\n * Transpose a note by an interval.\n *\n * @param {string} note - the note or note name\n * @param {string} interval - the interval or interval name\n * @return {string} the transposed note name or empty string if not valid notes\n * @example\n * import { tranpose } from \"@tonaljs/core\"\n * transpose(\"d3\", \"3M\") // => \"F#3\"\n * transpose(\"D\", \"3M\") // => \"F#\"\n * [\"C\", \"D\", \"E\", \"F\", \"G\"].map(pc => transpose(pc, \"M3)) // => [\"E\", \"F#\", \"G#\", \"A\", \"B\"]\n */\nexport function transpose(\n  noteName: NoteLiteral,\n  intervalName: IntervalLiteral | [number, number]\n): NoteName {\n  const note = asNote(noteName);\n  const intervalCoord = Array.isArray(intervalName)\n    ? intervalName\n    : asInterval(intervalName).coord;\n  if (note.empty || !intervalCoord || intervalCoord.length < 2) {\n    return \"\";\n  }\n  const noteCoord = note.coord;\n  const tr: PitchCoordinates =\n    noteCoord.length === 1\n      ? [noteCoord[0] + intervalCoord[0]]\n      : [noteCoord[0] + intervalCoord[0], noteCoord[1] + intervalCoord[1]];\n  return coordToNote(tr).name;\n}\n\n// Private\nexport function tonicIntervalsTransposer(\n  intervals: string[],\n  tonic: string | undefined | null\n) {\n  const len = intervals.length;\n  return (normalized: number) => {\n    if (!tonic) return \"\";\n    const index =\n      normalized < 0 ? (len - (-normalized % len)) % len : normalized % len;\n    const octaves = Math.floor(normalized / len);\n    const root = transpose(tonic, [0, octaves]);\n    return transpose(root, intervals[index]);\n  };\n}\n\n/**\n * Find the interval distance between two notes or coord classes.\n *\n * To find distance between coord classes, both notes must be coord classes and\n * the interval is always ascending\n *\n * @param {Note|string} from - the note or note name to calculate distance from\n * @param {Note|string} to - the note or note name to calculate distance to\n * @return {string} the interval name or empty string if not valid notes\n *\n */\nexport function distance(\n  fromNote: NoteLiteral,\n  toNote: NoteLiteral\n): IntervalName {\n  const from = asNote(fromNote);\n  const to = asNote(toNote);\n  if (from.empty || to.empty) {\n    return \"\";\n  }\n\n  const fcoord = from.coord;\n  const tcoord = to.coord;\n  const fifths = tcoord[0] - fcoord[0];\n  const octs =\n    fcoord.length === 2 && tcoord.length === 2\n      ? tcoord[1] - fcoord[1]\n      : -Math.floor((fifths * 7) / 12);\n\n  // If it's unison and not pitch class, it can be descending interval (#243)\n  const forceDescending =\n    to.height === from.height &&\n    to.midi !== null &&\n    from.midi !== null &&\n    from.step > to.step;\n  return coordToInterval([fifths, octs], forceDescending).name;\n}\n"],"mappings":"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","names":["REGEX","cache","parse","pitchName","note"]}