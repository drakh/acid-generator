/**
 * Fill a string with a repeated character
 *
 * @param character
 * @param repetition
 */
declare const fillStr: (s: string, n: number) => string;
declare function deprecate<ResultFn extends (this: any, ...newArgs: any[]) => ReturnType<ResultFn>>(original: string, alternative: string, fn: ResultFn): (this: unknown, ...args: unknown[]) => ReturnType<ResultFn>;

interface Named {
    readonly name: string;
}
interface NamedFound {
    readonly empty: false;
}
interface NotFound extends Named {
    readonly empty: true;
    readonly name: "";
}
declare function isNamed(src: any): src is Named;

type Fifths = number;
type Octaves = number;
type Direction = 1 | -1;
type PitchClassCoordinates = [Fifths];
type NoteCoordinates = [Fifths, Octaves];
type IntervalCoordinates = [Fifths, Octaves, Direction];
type PitchCoordinates = PitchClassCoordinates | NoteCoordinates | IntervalCoordinates;
/**
 * Pitch properties
 *
 * - {number} step - The step number: 0 = C, 1 = D, ... 6 = B
 * - {number} alt - Number of alterations: -2 = 'bb', -1 = 'b', 0 = '', 1 = '#', ...
 * - {number} [oct] = The octave (undefined when is a coord class)
 * - {number} [dir] = Interval direction (undefined when is not an interval)
 */
interface Pitch {
    readonly step: number;
    readonly alt: number;
    readonly oct?: number;
    readonly dir?: Direction;
}
declare function isPitch(pitch: any): pitch is Pitch;
declare function encode(pitch: Pitch): PitchCoordinates;
declare function decode(coord: PitchCoordinates): Pitch;

type NoteWithOctave = string;
type PcName = string;
type NoteName = NoteWithOctave | PcName;
type NoteLiteral = NoteName | Pitch | Named;
interface Note extends Pitch, Named {
    readonly empty: boolean;
    readonly name: NoteName;
    readonly letter: string;
    readonly acc: string;
    readonly pc: PcName;
    readonly chroma: number;
    readonly height: number;
    readonly coord: PitchCoordinates;
    readonly midi: number | null;
    readonly freq: number | null;
}
interface NoNote extends Partial<Note> {
    empty: true;
    name: "";
    pc: "";
    acc: "";
}
declare const stepToLetter: (step: number) => string;
declare const altToAcc: (alt: number) => string;
declare const accToAlt: (acc: string) => number;
/**
 * Given a note literal (a note name or a note object), returns the Note object
 * @example
 * note('Bb4') // => { name: "Bb4", midi: 70, chroma: 10, ... }
 */
declare function note(src: NoteLiteral): Note | NoNote;
type NoteTokens = [string, string, string, string];
/**
 * @private
 */
declare function tokenizeNote(str: string): NoteTokens;
/**
 * @private
 */
declare function coordToNote(noteCoord: PitchCoordinates): Note;

type IntervalName = string;
type IntervalLiteral = IntervalName | Pitch | Named;
type Quality = "dddd" | "ddd" | "dd" | "d" | "m" | "M" | "P" | "A" | "AA" | "AAA" | "AAAA";
type Type = "perfectable" | "majorable";
interface Interval extends Pitch, Named {
    readonly empty: boolean;
    readonly name: IntervalName;
    readonly num: number;
    readonly q: Quality;
    readonly type: Type;
    readonly step: number;
    readonly alt: number;
    readonly dir: Direction;
    readonly simple: number;
    readonly semitones: number;
    readonly chroma: number;
    readonly coord: IntervalCoordinates;
    readonly oct: number;
}
interface NoInterval extends Partial<Interval> {
    readonly empty: true;
    readonly name: "";
    readonly acc: "";
}
type IntervalTokens = [string, string];
/**
 * @private
 */
declare function tokenizeInterval(str?: IntervalName): IntervalTokens;
/**
 * Get interval properties. It returns an object with:
 *
 * - name: the interval name
 * - num: the interval number
 * - type: 'perfectable' or 'majorable'
 * - q: the interval quality (d, m, M, A)
 * - dir: interval direction (1 ascending, -1 descending)
 * - simple: the simplified number
 * - semitones: the size in semitones
 * - chroma: the interval chroma
 *
 * @param {string} interval - the interval name
 * @return {Object} the interval properties
 *
 * @example
 * import { interval } from '@tonaljs/core'
 * interval('P5').semitones // => 7
 * interval('m3').type // => 'majorable'
 */
declare function interval(src: IntervalLiteral): Interval | NoInterval;
/**
 * @private
 *
 * forceDescending is used in the case of unison (#243)
 */
declare function coordToInterval(coord: PitchCoordinates, forceDescending?: boolean): Interval;

/**
 * Transpose a note by an interval.
 *
 * @param {string} note - the note or note name
 * @param {string} interval - the interval or interval name
 * @return {string} the transposed note name or empty string if not valid notes
 * @example
 * import { tranpose } from "@tonaljs/core"
 * transpose("d3", "3M") // => "F#3"
 * transpose("D", "3M") // => "F#"
 * ["C", "D", "E", "F", "G"].map(pc => transpose(pc, "M3)) // => ["E", "F#", "G#", "A", "B"]
 */
declare function transpose(noteName: NoteLiteral, intervalName: IntervalLiteral | [number, number]): NoteName;
declare function tonicIntervalsTransposer(intervals: string[], tonic: string | undefined | null): (normalized: number) => string;
/**
 * Find the interval distance between two notes or coord classes.
 *
 * To find distance between coord classes, both notes must be coord classes and
 * the interval is always ascending
 *
 * @param {Note|string} from - the note or note name to calculate distance from
 * @param {Note|string} to - the note or note name to calculate distance to
 * @return {string} the interval name or empty string if not valid notes
 *
 */
declare function distance(fromNote: NoteLiteral, toNote: NoteLiteral): IntervalName;

export { Direction, Interval, IntervalCoordinates, IntervalLiteral, IntervalName, Named, NamedFound, NoInterval, NoNote, NotFound, Note, NoteCoordinates, NoteLiteral, NoteName, NoteWithOctave, PcName, Pitch, PitchClassCoordinates, PitchCoordinates, accToAlt, altToAcc, coordToInterval, coordToNote, decode, deprecate, distance, encode, fillStr, interval, isNamed, isPitch, note, stepToLetter, tokenizeInterval, tokenizeNote, tonicIntervalsTransposer, transpose };
