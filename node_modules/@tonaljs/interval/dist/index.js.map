{"version":3,"sources":["../index.ts"],"sourcesContent":["import {\n  coordToInterval,\n  distance as dist,\n  interval as props,\n  IntervalCoordinates,\n  IntervalName,\n  NoteCoordinates,\n  tokenizeInterval as tokenize,\n} from \"@tonaljs/core\";\n\n/**\n * Get the natural list of names\n */\nexport function names(): IntervalName[] {\n  return \"1P 2M 3M 4P 5P 6m 7m\".split(\" \");\n}\n\n/**\n * Get properties of an interval\n *\n * @function\n * @example\n * Interval.get('P4') // => {\"alt\": 0,  \"dir\": 1,  \"name\": \"4P\", \"num\": 4, \"oct\": 0, \"q\": \"P\", \"semitones\": 5, \"simple\": 4, \"step\": 3, \"type\": \"perfectable\"}\n */\nexport const get = props;\n\n/**\n * Get name of an interval\n *\n * @function\n * @example\n * Interval.name('4P') // => \"4P\"\n * Interval.name('P4') // => \"4P\"\n * Interval.name('C4') // => \"\"\n */\nexport const name = (name: string) => props(name).name;\n\n/**\n * Get semitones of an interval\n * @function\n * @example\n * Interval.semitones('P4') // => 5\n */\nexport const semitones = (name: string) => props(name).semitones;\n\n/**\n * Get quality of an interval\n * @function\n * @example\n * Interval.quality('P4') // => \"P\"\n */\nexport const quality = (name: string) => props(name).q;\n\n/**\n * Get number of an interval\n * @function\n * @example\n * Interval.num('P4') // => 4\n */\nexport const num = (name: string) => props(name).num;\n\n/**\n * Get the simplified version of an interval.\n *\n * @function\n * @param {string} interval - the interval to simplify\n * @return {string} the simplified interval\n *\n * @example\n * Interval.simplify(\"9M\") // => \"2M\"\n * Interval.simplify(\"2M\") // => \"2M\"\n * Interval.simplify(\"-2M\") // => \"7m\"\n * [\"8P\", \"9M\", \"10M\", \"11P\", \"12P\", \"13M\", \"14M\", \"15P\"].map(Interval.simplify)\n * // => [ \"8P\", \"2M\", \"3M\", \"4P\", \"5P\", \"6M\", \"7M\", \"8P\" ]\n */\nexport function simplify(name: IntervalName): IntervalName {\n  const i = props(name);\n  return i.empty ? \"\" : i.simple + i.q;\n}\n\n/**\n * Get the inversion (https://en.wikipedia.org/wiki/Inversion_(music)#Intervals)\n * of an interval.\n *\n * @function\n * @param {string} interval - the interval to invert in interval shorthand\n * notation or interval array notation\n * @return {string} the inverted interval\n *\n * @example\n * Interval.invert(\"3m\") // => \"6M\"\n * Interval.invert(\"2M\") // => \"7m\"\n */\nexport function invert(name: IntervalName): IntervalName {\n  const i = props(name);\n  if (i.empty) {\n    return \"\";\n  }\n  const step = (7 - i.step) % 7;\n  const alt = i.type === \"perfectable\" ? -i.alt : -(i.alt + 1);\n  return props({ step, alt, oct: i.oct, dir: i.dir }).name;\n}\n\n// interval numbers\nconst IN = [1, 2, 2, 3, 3, 4, 5, 5, 6, 6, 7, 7];\n// interval qualities\nconst IQ = \"P m M m M P d P m M m M\".split(\" \");\n\n/**\n * Get interval name from semitones number. Since there are several interval\n * names for the same number, the name it's arbitrary, but deterministic.\n *\n * @param {Integer} num - the number of semitones (can be negative)\n * @return {string} the interval name\n * @example\n * Interval.fromSemitones(7) // => \"5P\"\n * Interval.fromSemitones(-7) // => \"-5P\"\n */\nexport function fromSemitones(semitones: number): IntervalName {\n  const d = semitones < 0 ? -1 : 1;\n  const n = Math.abs(semitones);\n  const c = n % 12;\n  const o = Math.floor(n / 12);\n  return d * (IN[c] + 7 * o) + IQ[c];\n}\n\n/**\n * Find interval between two notes\n *\n * @example\n * Interval.distance(\"C4\", \"G4\"); // => \"5P\"\n */\nexport const distance = dist;\n\n/**\n * Adds two intervals\n *\n * @function\n * @param {string} interval1\n * @param {string} interval2\n * @return {string} the added interval name\n * @example\n * Interval.add(\"3m\", \"5P\") // => \"7m\"\n */\nexport const add = combinator((a, b) => [a[0] + b[0], a[1] + b[1]]);\n\n/**\n * Returns a function that adds an interval\n *\n * @function\n * @example\n * ['1P', '2M', '3M'].map(Interval.addTo('5P')) // => [\"5P\", \"6M\", \"7M\"]\n */\nexport const addTo = (interval: string) => (other: string) =>\n  add(interval, other);\n\n/**\n * Subtracts two intervals\n *\n * @function\n * @param {string} minuendInterval\n * @param {string} subtrahendInterval\n * @return {string} the substracted interval name\n * @example\n * Interval.substract('5P', '3M') // => '3m'\n * Interval.substract('3M', '5P') // => '-3m'\n */\nexport const substract = combinator((a, b) => [a[0] - b[0], a[1] - b[1]]);\n\nexport function transposeFifths(\n  interval: IntervalName,\n  fifths: number\n): IntervalName {\n  const ivl = get(interval);\n  if (ivl.empty) return \"\";\n\n  const [nFifths, nOcts, dir] = ivl.coord;\n  return coordToInterval([nFifths + fifths, nOcts, dir]).name;\n}\n\nexport default {\n  names,\n  get,\n  name,\n  num,\n  semitones,\n  quality,\n  fromSemitones,\n  distance,\n  invert,\n  simplify,\n  add,\n  addTo,\n  substract,\n  transposeFifths,\n};\n\n//// PRIVATE ////\n\ntype Operation = (\n  a: IntervalCoordinates,\n  b: IntervalCoordinates\n) => NoteCoordinates;\n\nfunction combinator(fn: Operation) {\n  return (a: IntervalName, b: IntervalName): IntervalName | undefined => {\n    const coordA = props(a).coord;\n    const coordB = props(b).coord;\n    if (coordA && coordB) {\n      const coord = fn(coordA, coordB);\n      return coordToInterval(coord).name;\n    }\n  };\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAQO;AAKA,SAAS,QAAwB;AACtC,SAAO,uBAAuB,MAAM,GAAG;AACzC;AASO,IAAM,MAAM,YAAAA;AAWZ,IAAM,OAAO,CAACC,cAAiB,YAAAD,UAAMC,KAAI,EAAE;AAQ3C,IAAM,YAAY,CAACA,cAAiB,YAAAD,UAAMC,KAAI,EAAE;AAQhD,IAAM,UAAU,CAACA,cAAiB,YAAAD,UAAMC,KAAI,EAAE;AAQ9C,IAAM,MAAM,CAACA,cAAiB,YAAAD,UAAMC,KAAI,EAAE;AAgB1C,SAAS,SAASA,OAAkC;AACzD,QAAM,QAAI,YAAAD,UAAMC,KAAI;AACpB,SAAO,EAAE,QAAQ,KAAK,EAAE,SAAS,EAAE;AACrC;AAeO,SAAS,OAAOA,OAAkC;AACvD,QAAM,QAAI,YAAAD,UAAMC,KAAI;AACpB,MAAI,EAAE,OAAO;AACX,WAAO;AAAA,EACT;AACA,QAAM,QAAQ,IAAI,EAAE,QAAQ;AAC5B,QAAM,MAAM,EAAE,SAAS,gBAAgB,CAAC,EAAE,MAAM,EAAE,EAAE,MAAM;AAC1D,aAAO,YAAAD,UAAM,EAAE,MAAM,KAAK,KAAK,EAAE,KAAK,KAAK,EAAE,IAAI,CAAC,EAAE;AACtD;AAGA,IAAM,KAAK,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AAE9C,IAAM,KAAK,0BAA0B,MAAM,GAAG;AAYvC,SAAS,cAAcE,YAAiC;AAC7D,QAAM,IAAIA,aAAY,IAAI,KAAK;AAC/B,QAAM,IAAI,KAAK,IAAIA,UAAS;AAC5B,QAAM,IAAI,IAAI;AACd,QAAM,IAAI,KAAK,MAAM,IAAI,EAAE;AAC3B,SAAO,KAAK,GAAG,KAAK,IAAI,KAAK,GAAG;AAClC;AAQO,IAAM,WAAW,YAAAC;AAYjB,IAAM,MAAM,WAAW,CAAC,GAAG,MAAM,CAAC,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,CAAC;AAS3D,IAAM,QAAQ,CAAC,aAAqB,CAAC,UAC1C,IAAI,UAAU,KAAK;AAad,IAAM,YAAY,WAAW,CAAC,GAAG,MAAM,CAAC,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,EAAE,CAAC;AAEjE,SAAS,gBACd,UACA,QACc;AACd,QAAM,MAAM,IAAI,QAAQ;AACxB,MAAI,IAAI;AAAO,WAAO;AAEtB,QAAM,CAAC,SAAS,OAAO,GAAG,IAAI,IAAI;AAClC,aAAO,6BAAgB,CAAC,UAAU,QAAQ,OAAO,GAAG,CAAC,EAAE;AACzD;AAEA,IAAO,mBAAQ;AAAA,EACb;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AASA,SAAS,WAAW,IAAe;AACjC,SAAO,CAAC,GAAiB,MAA8C;AACrE,UAAM,aAAS,YAAAH,UAAM,CAAC,EAAE;AACxB,UAAM,aAAS,YAAAA,UAAM,CAAC,EAAE;AACxB,QAAI,UAAU,QAAQ;AACpB,YAAM,QAAQ,GAAG,QAAQ,MAAM;AAC/B,iBAAO,6BAAgB,KAAK,EAAE;AAAA,IAChC;AAAA,EACF;AACF;","names":["props","name","semitones","dist"]}